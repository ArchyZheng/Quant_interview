# this file contains the training logic.
# %%
import pytorch_lightning as pl
import torch


def ic_loss(y_hat, y) -> torch.tensor:
    """

    :param y_hat: the prediction generated by model
    :param y: the target come form dataset
    :return IC(Information Coefficient) loss, the mean of IC
    """
    y_hat = torch.unsqueeze(y_hat, dim=0)
    y = torch.unsqueeze(y, dim=0)
    concat_tensor = torch.concat([y_hat, y], dim=0)
    return -1 * torch.corrcoef(concat_tensor)[0][1]


class TrainModule(pl.LightningModule):
    def __init__(self, model: torch.nn.Module, batch_size: int):
        super().__init__()
        self.batch_size = batch_size
        self.model = model
        self.loss = ic_loss

    def configure_optimizers(self):
        optimizer = torch.optim.Adam(self.model.parameters())
        return optimizer

    def training_step(self, train_batch, batch_idx):
        x, y = train_batch

        h_0 = self.model.init_hidden(batch_size=self.batch_size).to(x.device)
        y_hat, _ = self.model(x, h_0)
        loss = self.loss(y_hat, y)
        self.log('train_loss', loss, on_epoch=True)
        return loss

    def validation_step(self, val_batch, batch_idx):
        x, y = val_batch

        h_0 = self.model.init_hidden(batch_size=100).to(x.device)
        y_hat, _ = self.model(x, h_0)
        loss = self.loss(y_hat, y)
        self.log('validation_loss', loss, on_epoch=True)
        return loss
